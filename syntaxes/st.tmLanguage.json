{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Structured Text",
	"patterns": [
		{
			"include": "#comment_l"
		},
		{
			"include": "#comment_st"
		},
		{
			"include": "#comment_g"
		},
		{
			"include": "#strings_dq"
		},
		{
			"include": "#strings_sq"
		},
		{
			"include": "#meta"
		},
		{
			"include": "#variables"
		},
		{
			"include": "#keywords"
		},
		{
			"include": "#numbers"
		}
	],
	"repository": {
		"numbers": {
			"patterns": [
				{
					"name": "constant.numeric.integer.st",
					"match": "\\b(2#[0-9_]*)+\\b"
				},
				{
					"name": "constant.numeric.hex.st",
					"match": "\\b(16#[0-9A-Fa-f]*)+\\b"
				},
				{
					"name": "constant.numeric.float.st",
					"match": "\\b\\d*\\.\\d+([eE][\\-+]?\\d+)?\\b"
				},
				{
					"name": "constant.numeric.integer.st",
					"match": "\\b(\\d)+\\b"
				}
			]
		},
		"keywords": {
			"patterns": [
				{
					"name": "keyword.control.conditional.st",
					"match": "\\b(END_)?(IF|CASE|OF|ELSE|ELSIF|THEN)\\b"
				},
				{
					"name": "keyword.control.st",
					"match": "\\b(END_)?(WHILE|FOR|REPEAT|DO|TO|BY|AT|TASK|WITH|RETURN|EXIT|CONTINUE|USE)\\b"
				},
				{
					"name": "keyword.operator.assignment.st",
					"match": "(:=|\\^)"
				},
				{
					"name": "keyword.operator.logical.st",
					"match": "\\b(OR|AND|NOT|XOR|GE|LE|EQ|NE|GT|LT)\\b"
				},
				{
					"name": "keyword.operator.logical.st",
					"match": "(&|\\+|\\/|\\-|\\<|\\=|\\>)"
				},
				{
					"name": "keyword.operator.arithmetic.st",
					"match": "(\\+|\\-|\\/|\\*)"
				},
				{
					"name": "keyword.operator.arithmetic.st",
					"match": "\\b(ABS|SIN|MOD|ABS|ACOS|ASIN|ATAN|COS|EXP|EXPT|LN|LOG|SIN|SQRT|TAN|SEL|MUX|SHL|SHR|ROL|ROR|ADD|DIV|MUL|SUB)\\b"
				},
				{
					"name": "storage.type.st",
					"match": "\\b(INT|SINT|DINT|LINT|USINT|UINT|UDINT|ULINT|REAL|LREAL|TIME|DATE|TIME_OF_DAY|DATE_AND_TIME|STRING|BOOL|BYTE|WORLD|DWORLD|ARRAY|POINTER|LWORLD)\\b"
				},
				{
					"name": "entity.name.constant.st",
					"match": "\\b(TRUE|FALSE|NULL)\\b"
				},
				{
					"name": "entity.name.struct.st",
					"match": "\\b(END_)?(PROGRAM|CONFIGURATION|TCP|RESOURCE|CHANNEL|LIBRARY|FOLDER|BINARIES|INCLUDES|SOURCES|ACTION|STEP|INITIAL_STEP|TRANSACTION|TYPE|STRUCT|FUNCTION|FUNCTION_BLOCK|NAMESPACE)\\b"
				},
				{
					"name": "entity.name.type.st",
					"match": "\\b(VAR|VAR_INPUT|VAR_OUTPUT|VAR_IN_OUT|VAR_TEMP|VAR_GLOBAL|VAR_ACCESS|VAR_EXTERNAL|END_VAR)\\b"
				}
			]
		},
		"variables":{
			"patterns": [

				{
					"name": "variable.other.constant",
					"match": "\\b(T|DT|TOD)#[0-9:-_shmyd]*\\b"
				},
				{
					"name": "variable.other.constant",
					"match": "\\b[A-Za-z]{1,6}#[0-9]**\\b"
				},
				{
					"name": "variable.other.constant",
					"match": "\\%(I|Q|M)(X|B|W|D|L)[0-9\\.]*\\b"
				},
				{
					"name": "variable.other.constant",
					"match": "\\%(I|Q)[0-9\\.]*\\b"
				},
				{
					"name": "variable.function.st",
					"match": "\\b(RS|SR|TON|TP|TOF|TRUNC|CTD|CTU|CTUD|R_TRIG|F_TRIG|MOVE|CONCAT|DELETE|FIND|INSERT|LEFT|LEN|REPLACE|RIGHT|RTC|MID|SEMA|ROUND|FLOOR|CEIL|UNPACK|LIMIT|MAX|MIN)\\b"
				},
				{
					"name": "variable.function.st",
					"match": "\\b(SEL_|MUX_)[A-Za-z]*\\b"
				},
				{
					"name": "variable.function.st",
					"match": "\\b[A-Za-z_]*(_TO_)[A-Za-z_]*\\b"
				},
				{
					"name": "variable.function.st",
					"match": "\\b(TO_|FROM_|TRUNC_)[A-Za-z_]*\\b"
				},
				{
					"name": "variable.parameter.st",
					"match": "\\b\\.[A-Za-z_]*\\b"
				}
			]
		},
		"meta":{
			"patterns": [
				{
					"name": "meta.braces.st",
					"match": "[\\[\\]\\(\\)\\{\\}]"
				}
			]
		},
		"comment_l": {
			"name": "comment.line.st",
			"begin": "\\/\\/",
			"end": "$",
			"patterns": [
				{
					"name": "constant.character.escape.st",
					"match": "\\\\."
				}
			]
		},
		"comment_st": {
			"name": "comment.block.st",
			"begin": "\\(\\*",
			"end": "\\*\\)",
			"patterns": [
				{
					"name": "constant.character.escape.st",
					"match": "\\\\."
				}
			]
		},
		"comment_g": {
			"name": "comment.block.st",
			"begin": "\\/\\*",
			"end": "\\*\\/",
			"patterns": [
				{
					"name": "constant.character.escape.st",
					"match": "\\\\."
				}
			]
		},
		"strings_dq": {
			"name": "string.quoted.double.st",
			"begin": "\"",
			"end": "\"",
			"patterns": [
				{
					"name": "constant.character.escape.st",
					"match": "\\\\."
				}
			]
		},
		"strings_sq": {
			"name": "string.single.double.st",
			"begin": "'",
			"end": "'",
			"patterns": [
				{
					"name": "constant.character.escape.st",
					"match": "\\\\."
				}
			]
		}
	},
	"scopeName": "source.st"
}